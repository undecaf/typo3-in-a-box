#!/bin/bash

#
# Controls execution and configuration of TYPO3 in a container
# ============================================================
#
# For help, run this script without any arguments.
#
# Copyright F. Kasper <fkasper@modus-operandi.at> 2019
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# Constants
T3_IMAGE=undecaf/typo3-in-a-box
T3_ROOTDIR=/var/www/localhost
T3_DATADIR=/var/lib/typo3-db
CERT_BASENAME=/etc/ssl/apache2/custom
FILE_LIMIT='nofile=10000:15000'

# Bypass aliases
AWK=$(which awk)
BASENAME=$(which basename)
BINDFS=$(which bindfs 2>/dev/null)
CAT=$(which cat)
DF=$(which df)
DIRNAME=$(which dirname)
GREP=$(which grep)
HOSTNAME=$(which hostname)
LS=$(which ls)
MKDIR=$(which mkdir)
PRINTENV=$(which printenv)
SLEEP=$(which sleep)
STAT=$(which stat)
SUDO=$(which sudo)
UNAME=$(which uname)


# TODO Rerun under zsh if running in bash under Darwin

# --------------------------------------------------------------------------

# Prints $USAGE and an optional error message to stdout or stderr
# and exits with exit code 0 or 1, respectively.
#
# Arguments:
#   $1  (optional) error message: if specified then it is printed, and all
#       output is sent to stderr; otherwise $USAGE goes to stdout.
#
# Environment:
#   $USAGE usage information; how to preserve linefeeds in $USAGE:
#       USAGE=$(cat <<EOT
#           ... multiline text ...
#       EOT
#       )
#
usage() {
    local SCRIPT=$($BASENAME $0)
    local REDIR=
    local EXIT_CODE=0

    if [ -n "$1" ]; then
        $CAT >&2 <<- EOT

*** $1 ***
EOT
        REDIR=">&2"
        EXIT_CODE=1
    fi

    eval 'echo "$USAGE" '$REDIR
    exit $EXIT_CODE
}


# --------------------------------------------------------------------------

# Returns exit code 0 if this script runs under macOS (Darwin).
#
is_macos() {
    [ "$($UNAME)" = 'Darwin' ]
}


# --------------------------------------------------------------------------

# Matches a string against a regex and returns success if they match.
# Works in bash and zsh (copied from https://stackoverflow.com/questions/22537804/retrieve-a-word-after-a-regular-expression-in-shell-script#22539067).
#
# Additionally, the matched string(s) is returned in array variable ${RE_MATCH[@]},
# which works the same as bash's ${BASH_REMATCH[@]} variable: the overall
# match is stored in the 1st element of ${RE_MATCH[@]}, with matches for
# capture groups (parenthesized subexpressions), if any, stored in the remaining
# array elements.
#
# Arguments:
#   $1  string
#   $2  regular expression
#

# Make array indices in zsh start at 0 as in bash
test -n "$ZSH_VERSION" && setopt KSH_ARRAYS

function re_match {
  local EC
  unset -v RE_MATCH # initialize output variable

  [[ $1 =~ $2 ]] # perform the regex test
  EC=$? # save exit code

  if [[ $EC -eq 0 ]]; then # copy result to output variable
    [[ -n $BASH_VERSION ]] && RE_MATCH=( "${BASH_REMATCH[@]}" )
    [[ -n $ZSH_VERSION ]]  && RE_MATCH=( "$MATCH" "${match[@]}" )
  fi

  return $EC
}


# --------------------------------------------------------------------------

# Returns exit code 0 if the argument contains a '/'.
#
# Arguments:
#   $1  string to test
#
is_path() {
    local RE
    RE='.+/.+'
    [[ "$1" =~ $RE ]]
}


# --------------------------------------------------------------------------

# If the argument is a path, verify that at least the parent exists and that
# it is an empty directory.
#
# Arguments:
#   $1  path of a working directory to bind-mount, or a volume name
#
# Calls:
#   is_path
#
verify_dir() {
    if is_path "$1"; then
        # At least the parent directory must exist
        [ -d $($DIRNAME "$1") ] || usage "Working directory '$1' does not have a parent"

        # Mount point must be an empty directory
        [ -n "$($LS -A "$1" 2>/dev/null)" ] && usage "Working directory path '$1' is not an empty directory"
    fi
}


# --------------------------------------------------------------------------

# Canonicalizes a path and echoes it to stdout.
#
# Arguments:
#   $1  path to canonicalize
#
canonicalize() {
    (
        cd "$1"
        pwd -P
    )
}


# --------------------------------------------------------------------------

# Autocompletes a string and echoes it to stdout. Echoes the original
# string if autocompletion could not be achieved.
#
# Arguments:
#   $1  string to autocomplete
#   $2, $3, ...
#       autocompleted strings
#
autocomplete() {
    local ARG="$1"
    shift
    for AC in $@; do
        if [ "${AC##$ARG}" != "$AC" ]; then
            echo "$AC"
            return
        fi
    done

    echo "$ARG"
}


# --------------------------------------------------------------------------

# Runs the selected container engine with the given arguments. Echoes the
# run command to the console if T3_SHOW is non-empty.
#
# Arguments:
#   $1, $2, ...
#       arguments to be passed to the container engine
#
# Environment:
#   $T3_ENGINE
#   $T3_SHOW
#
run_engine() {
    [ -n "$T3_SHOW" ] && echo "$T3_ENGINE $@"
    $T3_ENGINE $@ >/dev/null
}


# --------------------------------------------------------------------------

# Bind-mounts a working directory to a container volume so that files and
# directories of that volume appear to be owned by the current user.
# Does nothing if no path was given.
#
# Arguments:
#   $1  name of container volume
#   $2  working directory path
#
# Environment:
#   $T3_ENGINE
#   $MP_FORMAT
#   $SUDO_PREFIX
#
# Calls:
#   is_path
#
mount_volume() {
    if is_path "$2"; then
        if [ -z "$BINDFS" ]; then
            unset USAGE
            usage "bindfs not installed, see https://bindfs.org/ for information"
        fi

        local BIND_MP
        local VOL_MP
        local VOL_UID
        local VOL_GID
        local FORMAT_OPT

        # Locate the volume mount point of the container engine
        VOL_MP=$($T3_ENGINE volume inspect --format "$MP_FORMAT" "$1") \
            || usage "Volume '$1' not found"

        # Acquire sudo authorization for what follows
        $SUDO --prompt $'\n*** sudo authorization is required for bind-mounting a working directory: ' --validate

        # Determine UID and GID of the volume owner (options differ between Linux and macOS)
        is_macos && FORMAT_OPT=-f || FORMAT_OPT=--format
        VOL_UID=$($SUDO_PREFIX $STAT $FORMAT_OPT '%u' $VOL_MP 2>/dev/null)
        VOL_GID=$($SUDO_PREFIX $STAT $FORMAT_OPT '%g' $VOL_MP 2>/dev/null)

        # Create the directory if necessary
        $MKDIR -p "$2"
        BIND_MP=$(canonicalize "$2")

        $SUDO $BINDFS \
            --map=$VOL_UID/$(id -u):@$VOL_GID/@$(id -g) \
            $VOL_MP \
            "$BIND_MP" \
        && echo "Working directory '$BIND_MP' bind-mounted to volume '$1'"
    fi
}


# --------------------------------------------------------------------------

# Unmounts whatever may be bind-mounted to a container volume mount point.
# Does nothing if nothing is mounted there.
#
# Arguments:
#   $1  name of container volume
#
# Environment:
#   $T3_ENGINE
#   $MP_FORMAT
#
unmount_volume() {
    # Find the container volume mountpoint
    local VOL_MP
    local LINE
    local RE

    VOL_MP=$($T3_ENGINE volume inspect "$1" --format=$MP_FORMAT)
    # {{- ...}} and {{... -}} do no work here, therefore:
    VOL_MP=$(echo $VOL_MP)

    # Find the directory bind-mounted to the container volume mountpoint
    RE='^/.+( +[0-9]+){4}% +(/.+)$'
    if LINE=$($DF -P -l | $GREP --fixed-string "$VOL_MP ") && re_match "$LINE" $RE; then
        $SUDO --prompt $'\n*** sudo authorization is required for unmounting a working directory: ' \
            umount "${RE_MATCH[2]}" \
        && echo "Working directory '${RE_MATCH[2]}' unmounted from volume '$1'"    
    fi
}


# --------------------------------------------------------------------------

# Determine command

[ -n "$1" ] && MSG="Unknown command: '$1'" || MSG="Missing command"

case "$1" in

    # Run TYPO3 in a container, optionally with a database in an extra container
    run)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) run [option]... [--] [Docker/Podman option]...
  $($BASENAME $0) run [-h|--help]

Runs TYPO3 image 'undecaf/typo3-in-a-box' in a container in Docker or Podman.

Although all options are optional, at least one option must be set
('--' is sufficient) as a precaution against inadvertent command invocation.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine to use: 'docker', 'podman' (can be abbreviated) or an 
      absolute path to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Container name.
      Default: \$T3_NAME, or 'typo3'.

  --hostname=HOSTNAME, -h HOSTNAME
      Hostname assigned to the TYPO3 container and to Apache ServerName and
      ServerAdmin.
      Default: \$T3_HOSTNAME, or 'typo3.$($HOSTNAME)'.

  --tag=TAG, -t TAG
      Tag of image to run, consisting of TYPO3 version and build version,
      e.g. '8.7-1.3' or '9.5-latest'.
      Default: \$T3_TAG, or 'latest', i.e. the latest build for the most recent
      TYPO3 version.

  --composer-mode, -c
      If this option is present then Composer is responsible for installing/
      removing TYPO3 extensions. Otherwise, this is handled by the TYPO3
      Extension Manager.
      Default: \$T3_COMPOSER_MODE, or not set.
 
  --typo3-vol=VOLUME, -v VOLUME
      Either a volume name to be mapped to the TYPO3 root directory inside the
      container, or a working directory path (containing a '/').
      In the latter case, the directory basename is used as the volume name,
      and the directory is bind-mounted at that volume. Thus, volume content
      appears to be owned by the current user.
      Default: \$T3_ROOT, or 'typo3-root'.

  --typo3-ports=HTTP,HTTPS, -p HTTP,HTTPS
      Host interfaces (optional) and ports where to publish the TYPO3 HTTP port
      and the TYPO3 HTTPS port. If one of the parts is omitted then the respective
      port will not be published.
      Default: \$T3_PORTS, or '127.0.0.1:8080,127.0.0.1:8443'.

  --certfiles=PRIVATE-KEY,CERT, -k PRIVATE-KEY,CERT
      Private key file and certificate file for HTTPS, in PEM format and located
      at the host. If not specified then a self-signed certificate will be used
      for HTTPS connections.
      Default: \$T3_CERTFILES, or not set.

  --db-type=TYPE, -d TYPE
      Type of database to use: 'sqlite' or empty for SQLite, 'mariadb' for 
      MariaDB or 'postgresql' for PostgreSQL (can be abbreviated).
      Default: \$T3_DB_TYPE, or 'sqlite'.

  --db-vol=VOLUME, -V VOLUME
      Database volume name or working directory path (see '--typo3-root').
      Defaults: \$T3_DB_DATA, or 'typo3-data'.

  --db-port=PORT, -P PORT
      Host interface (optional) and port where to publish the database port;
      effective only for MariaDB and PostgreSQL.
      Defaults: \$T3_DB_PORT, or '127.0.0.1:3306' for MariaDB and '127.0.0.1:5432'
      for PostgreSQL.
 
  --show, -s
      If this option is present then the generated Docker/Podman command will be
      shown on the console.
      Warning: your database credentials will be visible on the console.
      Default: \$T3_SHOW, or not set.

  --env NAME=VALUE
      Sets the (initial) value of a container environment variable. The values of
      certain variables can be changed afterwards by '$($BASENAME $0) env'.
      This option may appear multiple times. '--env' options must be the last options
      on the command line.
 
  --help, -h
      Displays this text and exits.

Additional options for the Docker/Podman 'run' command can be added after the options
described above. If necessary, '--' can be used to separate them from the $($BASENAME $0) options.
 
EOT
        )
        ALLOWED_OPTS='-d|--db-type(=.*)?|-e|--engine(=.+)?|-h|--hostname(=.+)?|-n|--name(=.+)?|-t|--tag(=.+)?|-c|--composer-mode|-v|--typo3-root(=.+)?|-V|--db-data(=.+)?|-p|--typo3-ports(=.+)?|-k|--certfiles(=.+)?|-P|--db-port(=.+)?|-s|--show'
        ;;


    # Stop and remove a running TYPO3 (and the respective database) container
    stop)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) stop [option]...
  $($BASENAME $0) stop [-h|--help]

Stops a running TYPO3 (and the associated database) container.

Although all options are optional, at least one option must be set
('--' is sufficient) as a precaution against inadvertent command invocation.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --show, -s
      If this option is present then the generated Docker/Podman command will be
      shown on the console.
      Default: \$T3_SHOW, or not set.
 
  --rm
      Causes the TYPO3 container and the respective database container (if one 
      exists) to be removed after they were stopped.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ALLOWED_OPTS='-e|--engine(=.+)?|-n|--name(=.+)?|-s|--show|--rm'
        ;;


    # Change environment settings in a running TYPO3 container
    env)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) env [option]... [NAME=VALUE]...
  $($BASENAME $0) env [-h|--help]

Modifies the environment of a running TYPO3 container.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --show, -s
      If this option is present then the generated Docker/Podman command will be
      shown on the console.
      Default: \$T3_SHOW, or not set.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ALLOWED_OPTS='-e|--engine(=.+)?|-n|--name(=.+)?|-s|--show'
        ;;


    # Run Composer in a running TYPO3 container
    composer)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) composer [option]... COMPOSER_CMD [Composer option]...
  $($BASENAME $0) composer [-h|--help]

Executes a Composer command inside of a running TYPO3 container.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --show, -s
      If this option is present then the generated Docker/Podman command will be
      shown on the console.
      Default: \$T3_SHOW, or not set.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ALLOWED_OPTS='-e|--engine(=.+)?|-n|--name(=.+)?|-s|--show'
        ;;


    # Bind-mount a directory to a container volume
    mount)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) mount [--mount|-m] WORK_DIR [option]...
  $($BASENAME $0) mount [-h|--help]

Mounts a working directory to a container volume so that the volume
appears to be owned and can be managed by the current user.
 
Equivalent to '$($BASENAME $0) run' with a directory path for '--typo3-vol'
except that the container does not need to be running (it does not even 
have to exist).

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --mount=WORK_DIR, -m WORK_DIR
      Path of a working directory to bind-mount to a persistent
      volume. The basename of this path is taken as the name of the
      persistent volume.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ALLOWED_OPTS='-e|--engine(=.+)?|-m|--mount(=.+)?'
        ;;


    # Unmount a bind-mouted directory from a container volume
    unmount)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) unmount [--unmount|-u] WORK_DIR [option]...
  $($BASENAME $0) unmount [-h|--help]

Unmounts a working directory from the container volume.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --unmount=WORK_DIR, -u WORK_DIR
      Path of the working directory to unmount from a persistent volume.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ALLOWED_OPTS='-e|--engine(=.+)?|-u|--unmount(=.+)?'
        ;;


    # General help
    -h|--help)
        MSG=
        ;&


    # Unknown command
    *)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) COMMAND [option]...

Commands:

  run           Runs TYPO3 image 'undecaf/typo3-in-a-box' in a container in Docker or
                Podman.
 
  stop          Stops a running TYPO3 (and the associated database) container.

  env           Modifies the environment of a running TYPO3 container.

  composer      When in Composer Mode, executes a Composer command inside a 
                running TYPO3 container.

  mount         Mounts a working directory to a container volume so that the
                volume appears to be owned and can be managed by the current user.

  unmount       Unmounts a working directory from the container volume.

  --help, -h    Displays this text and exits. Displays command-specific help if 
                combined with a command.
 
EOT
        )
        usage "$MSG"
        ;;
esac

# Save command
CMD="$1"
shift
OPT_COUNT=$#


# --------------------------------------------------------------------------

# Process command line options

# Default options, overridden by environment variables
T3_ENGINE=${T3_ENGINE:-$(which podman)} || T3_ENGINE=docker
T3_NAME=${T3_NAME:-typo3}
T3_HOSTNAME=${T3_HOSTNAME:-typo3.$($HOSTNAME)}

T3_TAG=${T3_TAG:-latest}
T3_ROOT=${T3_ROOT:-typo3-root}
T3_PORTS=${T3_PORTS:-127.0.0.1:8080,127.0.0.1:8443}

REMOVE_OPTION=
MOUNT_PATH=

ALLOWED_OPTS='^('"$ALLOWED_OPTS"'|-h|--help|--)$'

while [[ $# -gt 0 ]]; do
    # Check for allowed options by regular expression
    [[ "$1" =~ $ALLOWED_OPTS ]] || break

    case "$1" in
        # Database type
        -d|--db-type)
            shift
            ;&

        --db-type=*)
            T3_DB_TYPE="${1#--db-type=}"   # validated later
            shift
            ;;

        # Container engine
        -e|--engine)
            shift
            ;&

        --engine=*)
            T3_ENGINE="${1#--engine=}"  # basename or absolute path of an executable
            shift
            ;;

        # Hostname
        -h|--hostname)
            shift
            ;&

        --hostname=*)
            T3_HOSTNAME="${1#--hostname=}"
            shift
            ;;

        # Container name
        -n|--name)
            shift
            ;&

        --name=*)
            T3_NAME="${1#--name=}"
            shift
            ;;

        # Composer Mode
        -c|--composer-mode)
            T3_COMPOSER_MODE=on
            shift
            ;;

        # Show container engine commands
        -s|--show)
            T3_SHOW=on
            shift
            ;;

        # Image tag
        -t|--tag)
            shift
            ;&

        --tag=*)
            T3_TAG="${1#--tag=}"
            shift
            ;;

        # Directory to be bind-mounted
        -m|--mount)
            shift
            ;&

        --mount=*)
            MOUNT_PATH="${1#--mount=}"
            verify_dir "$MOUNT_PATH"
            shift
            ;;

        # Directory to be unmounted
        -u|--unmount)
            shift
            ;&

        --unmount=*)
            MOUNT_PATH="${1#--unmount=}"
            shift
            ;;

        # TYPO3 volume (volume name or absolute path)
        # If an absolute path is given then its basename is used as the name
        # of a volume which is mounted at the absolute path
        -v|--typo3-root)
            shift
            ;&

        --typo3-root=*)
            T3_ROOT="${1#--typo3-root=}"
            verify_dir "$T3_ROOT"
            shift
            ;;

        # Database volume (volume name or absolute path)
        # If an absolute path is given then its basename is used as the name
        # of a volume which is mounted at the absolute path
        -V|--db-data)
            shift
            ;&

        --db-data=*)
            T3_DB_DATA="${1#--db-data=}"
            verify_dir "$T3_DB_DATA"
            shift
            ;;

        # TYPO3 HTTP and HTTPS interfaces and ports
        -p|--typo3-ports)
            shift
            ;&

        --typo3-ports=*)
            T3_PORTS="${1#--typo3-ports=}"
            shift
            ;;

        # Private key file and certificate file
        -k|--certfiles)
            shift
            ;&

        --certfiles=*)
            T3_CERTFILES="${1#--certfiles=}"
            shift
            ;;

        # Database port
        -P|--db-port)
            shift
            ;&

        --db-port=*)
            T3_DB_PORT="${1#--db-port=}"
            shift
            ;;

        # Remove container(s) after being stopped
        --rm)
            REMOVE_OPTION='--rm'
            shift
            ;;

        # Help for selected command
        -h|--help)
            usage
            ;;

        # Separator from container engine options
        --)
            shift
            break
            ;;

        # First unknown option, pass through to the container engine
        *)
            break
            ;;
    esac
done

# At least one option must be present
[ $OPT_COUNT -eq 0 ] && usage 'No option was found but at least one is required'


# --------------------------------------------------------------------------

# Set up the container environment
ENV_OPTIONS="--env T3_COMPOSER_MODE=$T3_COMPOSER_MODE "

# Determine container engine name
T3_ENGINE=$(autocomplete "$T3_ENGINE" docker podman)
[ -x "$(which $T3_ENGINE)" ] || usage "Container engine '$T3_ENGINE' not found"

T3_ENGINE=$(which $T3_ENGINE)
ENGINE_NAME=$($BASENAME $T3_ENGINE)

# Options that differ between container engines
case $ENGINE_NAME in
    docker)
        HOST_IP_ENV=
        MP_FORMAT='{{.Mountpoint}}'
        SUDO_PREFIX=$SUDO
        ;;

    podman)
        # hostname -I is not supported under macOS, therefore:
        HOST_IP_ENV="HOST_IP=$(ifconfig | $GREP 'inet ' | $GREP -v '127.0.0.1' | $AWK '{ print $2; }' | head -n 1)"
        ENV_OPTIONS="$ENV_OPTIONS \
            --env $HOST_IP_ENV"
        MP_FORMAT='{{.MountPoint}}'
        SUDO_PREFIX=
        ;;
esac

# Split into HTTP and HTTPS port and interface
RE='^((.+?)?,(.+?)?)?$'
re_match "$T3_PORTS" $RE || usage "Invalid option: '$T3_PORTS'"
HTTP_PORT=${RE_MATCH[2]}
HTTPS_PORT=${RE_MATCH[3]}

HTTP_OPTIONS=
[ -n "$HTTP_PORT" ] && HTTP_OPTIONS="$HTTP_OPTIONS --publish $HTTP_PORT:80"
[ -n "$HTTPS_PORT" ] && HTTP_OPTIONS="$HTTP_OPTIONS --publish $HTTPS_PORT:443"

# Split into private key file and certificate file
RE='^((.+),(.+))?$'
re_match "$T3_CERTFILES" $RE || usage "Invalid option: '$T3_CERTFILES'"
KEY_FILE=${RE_MATCH[2]}
CERT_FILE=${RE_MATCH[3]}

# Volume names and working directories
ROOT_MP=
if is_path "$T3_ROOT"; then
    ROOT_MP="$T3_ROOT"
    T3_ROOT=$($BASENAME "$T3_ROOT")
fi

DB_DATA_MP=
if is_path "$T3_DB_DATA"; then
    DB_DATA_MP="$T3_DB_DATA"
    T3_DB_DATA=$($BASENAME "$T3_DB_DATA")
fi

# Initialize container environment variables
RE='^T3_(TIMEZONE|LANG|MODE|COMPOSER_EXCLUDE|PHP_.+|php_.+)=(.*)$'

while read -r ENV_VAR; do
    if re_match "$ENV_VAR" $RE; then
        ENV_OPTIONS="$ENV_OPTIONS \
            --env ${RE_MATCH[1]}=${RE_MATCH[2]}"
    fi
done <<< "$($PRINTENV)"

# Database type-specific settings
T3_DB_TYPE=$(autocomplete "$T3_DB_TYPE" sqlite mariadb postgresql)
T3_DB_DATA=${T3_DB_DATA:-typo3-data}

ENV_OPTIONS="$ENV_OPTIONS \
    --env T3_DB_TYPE=${T3_DB_TYPE:-sqlite}"

case "$T3_DB_TYPE" in
    mariadb)
        DB_CONTAINER_PORT=3306
        ;;

    postgresql)
        DB_CONTAINER_PORT=5432
        ;;
esac

case "$T3_DB_TYPE" in
    mariadb|postgresql)
        T3_DB_PORT=${T3_DB_PORT:-127.0.0.1:$DB_CONTAINER_PORT}
        DB_PORT_OPTION="--publish $T3_DB_PORT:$DB_CONTAINER_PORT"
        ENV_OPTIONS="$ENV_OPTIONS \
            --env T3_DB_NAME=${T3_DB_NAME:-t3} \
            --env T3_DB_USER=${T3_DB_USER:-t3} \
            --env T3_DB_PW=${T3_DB_PW:-t3} \
            --env T3_DB_ROOT_PW=${T3_DB_ROOT_PW:-toor}"
        ;;

    sqlite|'')
        T3_DB_PORT=
        DB_PORT_OPTION=
        ;;

    *)
        usage "Unknown database type: '$T3_DB_TYPE'"
        ;;
esac


# --------------------------------------------------------------------------

# Execute command

case "$CMD" in

    run)
        # Roll back if command terminates prematurely
        trap "echo $'\n*** Command failed or interrupted, rolling back ***'; $0 stop -e '$T3_ENGINE' -n '$T3_NAME' --rm; exit 1" EXIT

        # Create the TYPO3 container
        set -e
        echo '*** '"Preparing container '$T3_NAME'"' ***'
        run_engine create \
            --name "$T3_NAME" \
            --hostname "$T3_HOSTNAME" \
            --ulimit $FILE_LIMIT \
            --volume "$T3_ROOT:$T3_ROOTDIR" \
            --volume "$T3_DB_DATA:$T3_DATADIR" \
            $HTTP_OPTIONS \
            $DB_VOL_OPTION \
            $DB_PORT_OPTION \
            $ENV_OPTIONS \
            $@ \
            $T3_IMAGE${T3_TAG:+:$T3_TAG}

        # Copy certificate files, if any
        if [ -n "$T3_CERTFILES" ]; then
            run_engine cp "$KEY_FILE" "$T3_NAME":${CERT_BASENAME}.key
            run_engine cp "$CERT_FILE" "$T3_NAME":${CERT_BASENAME}.pem
        fi
        echo '*** '"Container '$T3_NAME' created"' ***'

        # Start the container
        run_engine start "$T3_NAME"
        echo '*** '"Container '$T3_NAME' started"' ***'

        # Eventually bind-mount container volumes in userspace
        mount_volume "$T3_ROOT" "$ROOT_MP"
        mount_volume "$T3_DB_DATA" "$DB_DATA_MP"

        trap - EXIT
        ;;


    stop)
        echo '*** '"Stopping container '$T3_NAME'"' ***'

        # Collect volume names from container
        # Note: prior to Podman v1.4.3, the volume name was contained in property .Source, not .Name
        VOLNAMES="$($T3_ENGINE container inspect \
            --format='{{range .Mounts}}{{if eq .Destination "'$T3_ROOTDIR'" "'$T3_DATADIR'"}}{{printf "%s " .Name}}{{end}}{{end}}' \
            "$T3_NAME" 2>/dev/null)"

        # Try to unmount whatever may be mounted at the mountpoint of each volume
        for VOLNAME in $VOLNAMES; do
            unmount_volume "$VOLNAME"
        done

        # Stop and eventually remove the container
        #stop_container "$T3_NAME"
        if run_engine kill --signal SIGINT "$T3_NAME" && run_engine stop --time 5 "$T3_NAME"; then
            echo '*** '"Container '$T3_NAME' stopped"' ***'
        fi

        # Remove the container(s) if so requested
        [ -n "$REMOVE_OPTION" ] && run_engine container rm "$T3_NAME"

        # Wait until the container was removed eventually
        $SLEEP 1
        $T3_ENGINE container inspect "$T3_NAME" &>/dev/null || echo '*** '"Container '$T3_NAME' removed"' ***'
        ;;


    env)
        run_engine exec "$T3_NAME" setenv $HOST_IP_ENV $@
        ;;


    composer)
        run_engine exec "$T3_NAME" composer $@
        ;;


    mount)
        [ -n "$MOUNT_PATH" ] || usage "Option '--mount' is required"
        mount_volume $($BASENAME "$MOUNT_PATH") "$MOUNT_PATH"
        ;;


    unmount)
        [ -d "$MOUNT_PATH" ] || usage "Option '--unmount' is required"
        $SUDO --prompt $'\n*** sudo authorization is required for unmounting a working directory: ' \
            umount "$MOUNT_PATH" \
        && echo '*** '"Working directory '$MOUNT_PATH' unmounted from volume '$($BASENAME "$MOUNT_PATH")'"' ***'
        ;;


    *)
        usage "Unknown command: '$CMD'"
        ;;
esac
